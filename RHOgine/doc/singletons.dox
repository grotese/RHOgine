/**	
  *	\page singleton_page Singletons
  *	\section template_class Singleton Template
  *	How to define a Singleton Object
  *	All Singletons are defines by inheriting the rho::FirstComeSingleton template class with their type being the templated type.
  *	For Example, if I wanted to make a new class called Highlander, I would define it this way:
  *	\code
  *	class Highlander : public rho::FirstComeSingleton< Highlander >
  *	{
  *		...
  *	};
  *	\endcode
  * Then, later in the cpp file, you need to instanciate the static instance. I made a dumb little macro to help:
  *	\code
  *	FIRST_COME_SINGLETON_INSTANCE(Highlander);
  *	\endcode
  *	All Singletons of this type need to be grounded somewhere.  So Instantiate a normal instance somewhere in a major class that has the same scope and lifespan you want the singleton to have.
  *	Protip: rho::cRHOgine or one of it's children.  This guy will last the entire game ( because he is the game ).
  *	\code
  *	// .. In cRHOGine or something
  *	Highlander g_highlander;	// fine
  *	...
  *	g_highlander.dosomething():					// fine
  *	Highlander::GetInstance().dosomething():	// fine
  *	rho::FirstComeSingleton< Highlander >::GetInstance().dosomething():	// also fine
  *	...
  *	Highlander another_highlander;		// BAD Making two sinlgetons of the same type will cause assert error
  *	...
  *	// .. If cRHOgine goes out of scope ( somehow )
  *	Highlander::GetInstance().dosomething():	// BAD no singleton is declared for this type, as the previous one went out of scope and was deleted, assert error
  *	\endcode
  *
  *	\image html highlander.jpg "How the Engine Instantiates a Singleton"
  *	\section singleton_list Singletons
  *	List of all Singletons in the Engine
  *	\li \c rho::cRHOgine
  *	\li \c rho::EventManager
  *	\li \c rho::GOComponentFactoryManager
  *	\li \c rho::GOFactoryManager
  *	\li \c rho::GameObjectManager
  *	\li \c rho::TextureManager
  *	\li \c rho::LuaState
  *	\li \c rho::SFMLInput
  */	
